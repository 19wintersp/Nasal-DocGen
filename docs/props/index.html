<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8" />

		<title>Namespace globals.props</title>

		<meta name="color-scheme" content="dark light" />
		<meta name="description" content="
Node class definition.  The class methods simply wrap the
low level extension functions which work on a &#34;ghost&#34; handle to a
SGPropertyNode object stored in the _g field.

Not all of the features of SGPropertyNode are supported.  There is
no support for ties, obviously, as that wouldn&#39;t make much sense
from a Nasal context.  The various get/set methods work only on the
local node, there is no equivalent of the &#34;relative path&#34; variants
available in C++; just use node.getNode(path).whatever() instead.

" />
		<meta name="generator" content="nasal-docgen" />
		<meta name="viewport" content="width=device-width,initial-scale=1" />

		<meta name="og:description" content="
Node class definition.  The class methods simply wrap the
low level extension functions which work on a &#34;ghost&#34; handle to a
SGPropertyNode object stored in the _g field.

Not all of the features of SGPropertyNode are supported.  There is
no support for ties, obviously, as that wouldn&#39;t make much sense
from a Nasal context.  The various get/set methods work only on the
local node, there is no equivalent of the &#34;relative path&#34; variants
available in C++; just use node.getNode(path).whatever() instead.

" />
		<meta name="og:image" content="../card.png" />
		<meta name="og:locale" content="en" />
		<meta name="og:site_name" content="Library globals" />
		<meta name="og:title" content="Namespace globals.props" />
		<meta name="og:type" content="website" />
		<!-- <meta name="og:url" content="..." /> -->

		<link rel="stylesheet" href="../style.css" />

		<link rel="apple-touch-icon" href="../icon.png" />
		<!-- <link rel="canonical" href="..." /> -->
		<link rel="icon" href="../favicon.png" />
	</head>

	<body>
		<details id="toggle">
			<summary>
				<header>
					<h2>Library <a href="../index.html">globals</a></h2>
					<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M3 4H21V6H3V4ZM3 11H21V13H3V11ZM3 18H21V20H3V18Z" /></svg>
				</header>
			</summary>
		</details>

		<nav>
			<h2>Library <a href="../index.html">globals</a></h2>

			<ul class="flex">
				<li><a href="../list.html">All items</a></li>
				<li><a href="../src.html">Sources</a></li>
			</ul>

			<div class="flex">
				<h3>Namespace</h3>
				<ul class="flex">
					<li><a href="#description">Description</a></li>
										 <li><a href="#classes">Classes</a></li> 					 <li><a href="#funcs">Functions</a></li> 					 <li><a href="#vars">Variables</a></li> 				</ul>
			</div>

			<div class="spacer"></div>

			<footer>
				<p class="mini">
					Generated by
					<a href="https://github.com/19wintersp/Nasal-DocGen">nasal-docgen</a>
					on 2023-05-16.
				</p>
			</footer>
		</nav>

		<main>
			<h1>
				
					<span>Namespace</span>
					
						<a href="../index.html">
							globals
						</a>
						<svg class="sep" width="14" height="16" viewBox="0 0 14 16" xmlns="http://www.w3.org/2000/svg"><title>.</title><path d="M13.8564 8L0 16V0L13.8564 8Z" /></svg>
										<span>props</span>
							</h1>

			
				<p><a href="../src/props.nas.html#1">
					View source
				</a></p>
			
			<div id="description"><pre>
Node class definition.  The class methods simply wrap the
low level extension functions which work on a "ghost" handle to a
SGPropertyNode object stored in the _g field.

Not all of the features of SGPropertyNode are supported.  There is
no support for ties, obviously, as that wouldn't make much sense
from a Nasal context.  The various get/set methods work only on the
local node, there is no equivalent of the "relative path" variants
available in C++; just use node.getNode(path).whatever() instead.

</pre></div>

			
			
				<h2 id="classes">Classes</h2>

				
					<div class="flex">
						<h3><a href="Node/index.html">Node</a></h3>
						 <p>
Node class definition.  The class methods simply wrap the
low level extension functions which work on a &#34;ghost&#34; handle to a
SGPropertyNode object stored in the _g field.

Not all of the features of SGPropertyNode are supported.  There is
no support for ties, obviously, as that wouldn&#39;t make much sense
from a Nasal context.  The various get/set methods work only on the
local node, there is no equivalent of the &#34;relative path&#34; variants
available in C++; just use node.getNode(path).whatever() instead.

</p> 					</div>
				
					<div class="flex">
						<h3><a href="UpdateManager/index.html">UpdateManager</a></h3>
						 <p>example usage:
this is using the hashlist (which works well with an Emesary notification)
basically when the method is called it will call each section (in the lambda)
when the value changes by more than the amount specified as the second parameter.
It is possible to reference multiple elements from the hashlist in each FromHashList; if either
one changes then it will result in the lambda being called.

obj.update_items = [
UpdateManager.FromHashList([&#34;VV_x&#34;,&#34;VV_y&#34;], 0.01, func(val)
{
obj.VV.setTranslation (val.VV_x, val.VV_y + pitch_offset);
}),
UpdateManager.FromHashList([&#34;pitch&#34;,&#34;roll&#34;], 0.025, func(hdp)
{
obj.ladder.setTranslation (0.0, hdp.pitch * pitch_factor+pitch_offset);
obj.ladder.setCenter (118,830 - hdp.pitch * pitch_factor-pitch_offset);
obj.ladder.setRotation (-hdp.roll_rad);
obj.roll_pointer.setRotation (hdp.roll_rad);
}),
props.UpdateManager.FromProperty(&#34;velocities/airspeed-kt&#34;, 0.01, func(val)
{
obj.ias_range.setTranslation(0, val * ias_range_factor);
}),
props.UpdateManager.FromPropertyHashList([&#34;orientation/alpha-indicated-deg&#34;, &#34;orientation/side-slip-deg&#34;], 0.1, func(val)
{
obj.VV_x = val.property[&#34;orientation/side-slip-deg&#34;].getValue()*10; # adjust for view
obj.VV_y = val.property[&#34;orientation/alpha-indicated-deg&#34;].getValue()*10; # adjust for view
obj.VV.setTranslation (obj.VV_x, obj.VV_y);
}),
]

==== the update loop then becomes ======

foreach(var update_item; me.update_items)
{
# hdp is a data provider that can be used as the hashlist for the property
# update from hash methods.
update_item.update(hdp);
}

</p> 					</div>
							
			
				<h2 id="funcs">Functions</h2>

				
					<div class="flex">
						<h3><a href="func.compileCondition.html">compileCondition</a></h3>
						 <p>
Compiles a &#60;condition&#62; property branch according to the rules
set out in $FG_ROOT/Docs/README.conditions into a Condition object.
The &#39;test&#39; method of the returend object can be used to evaluate
the condition.
The function returns nil on error.

</p> 					</div>
				
					<div class="flex">
						<h3><a href="func.condition.html">condition</a></h3>
						 <p>
Evaluates a &#60;condition&#62; property branch according to the rules
set out in $FG_ROOT/Docs/README.conditions. Undefined conditions
and a nil argument are &#34;true&#34;. The function dumps the condition
branch and returns nil on error.

</p> 					</div>
				
					<div class="flex">
						<h3><a href="func.copy.html">copy</a></h3>
						 <p>
Recursively copy property branch from source Node to
destination Node. Doesn&#39;t copy aliases. Copies attributes
if optional third argument is set and non-zero.

</p> 					</div>
				
					<div class="flex">
						<h3><a href="func.createNodeObjectsFromHash.html">createNodeObjectsFromHash</a></h3>
						 <p>createNodeObjectsFromHash - create nasal node objects from hash
property_list: hash; where keys are variable names and values are
property paths
{ foo: &#34;/some/prop/foo&#34;, bar: &#34;/some/other/prop&#34;, }
namespace:     optional; variables (objects) are created in this namespace
defaults to namespace of caller, e.g. after calling this
you can use foo.getValue() or bar.addChild()

</p> 					</div>
				
					<div class="flex">
						<h3><a href="func.dump.html">dump</a></h3>
						 <p>
Useful debugging utility.  Recursively dumps the full state of a
Node object to the console.  Try binding &#34;props.dump(props.globals)&#34;
to a key for a fun hack.

</p> 					</div>
				
					<div class="flex">
						<h3><a href="func.getNode.html">getNode</a></h3>
						 <p>
Shortcut for props.globals.getNode().

</p> 					</div>
				
					<div class="flex">
						<h3><a href="func.nodeList.html">nodeList</a></h3>
						 <p>
Turns about anything into a list of props.Nodes, including ghosts,
path strings, vectors or hashes containing, as well as functions
returning any of the former and in arbitrary nesting. This is meant
to be used in functions whose main purpose is to handle collections
of properties.

</p> 					</div>
				
					<div class="flex">
						<h3><a href="func.runBinding.html">runBinding</a></h3>
						 <p>
Runs &#60;binding&#62; as described in $FG_ROOT/Docs/README.commands using
a given module by default, and returns 1 if fgcommand() succeeded,
or 0 otherwise. The module name won&#39;t override a &#60;module&#62; defined
in the binding.

</p> 					</div>
				
					<div class="flex">
						<h3><a href="func.setAll.html">setAll</a></h3>
						 <p>
Sets all indexed property children to a single value.  arg[0]
specifies a property name (e.g. /controls/engines/engine), arg[1] a
path under each node of that name to set (e.g. &#34;throttle&#34;), arg[2]
is the value.

</p> 					</div>
				
					<div class="flex">
						<h3><a href="func.wrap.html">wrap</a></h3>
						 <p>
Utility.  Turns any ghosts it finds (either solo, or in an
array) into Node objects.

</p> 					</div>
				
					<div class="flex">
						<h3><a href="func.wrapNode.html">wrapNode</a></h3>
						 <p>
Utility.  Returns a new object with its superclass/parent set to the
Node object and its _g (ghost) field set to the specified object.
Nasal&#39;s literal syntax can be pleasingly terse. I like that. :)

</p> 					</div>
							
			
				<h2 id="vars">Variables</h2>

				
					<div class="flex">
						<h3><a href="var.globals.html">globals</a></h3>
						 <p>
Global property tree.  Set once at initialization.  Is that OK?
Does anything ever call globals.set_props() from C++?  May need to
turn this into a function if so.

</p> 					</div>
									</main>
	</body>
</html>
